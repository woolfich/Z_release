{
  "src/routes/+page.svelte": "<script lang=\"ts\">
    import ImportExport from '$lib/components/ImportExport.svelte';
    import WelderCalendarModal from '$lib/components/WelderCalendarModal.svelte'; // <-- 1. Импортируем наш компонент
    import { onMount } from 'svelte';
    import { db, type Welder } from '$lib/db';
    import { base } from '$app/paths';

    let newWelderName = '';
    let welders: Welder[] = [];

    // --- 2. НОВОЕ: Состояние для модального окна ---
    let showWelderModal = false;
    let selectedWelder: Welder | null = null;
    // --- КОНЕЦ НОВОГО ---

    async function loadWelders() {
        welders = await db.welders.orderBy('name').toArray();
    }

    async function addWelder() {
        if (newWelderName.trim() === '') {
            alert('Введите фамилию!');
            return;
        }
        await db.welders.add({ name: newWelderName.trim() });
        newWelderName = '';
        await loadWelders();
    }

    // --- 3. НОВОЕ: Реализация долгого нажатия ---
    const LONG_PRESS_MS = 500; // 0.5 секунды
    const MOVE_CANCEL_PX = 10;

    type PressState = {
        timeoutId: number | null;
        startX: number;
        startY: number;
        triggered: boolean;
    };
    const pressStates = new Map<number, PressState>();

    function startPress(e: PointerEvent, welder: Welder) {
        if ((e instanceof PointerEvent) && e.button && e.button !== 0) return;
        const id = e.pointerId;
        const startX = (e as PointerEvent).clientX ?? 0;
        const startY = (e as PointerEvent).clientY ?? 0;
        if (pressStates.has(id)) clearPressState(id);
        const timeoutId = window.setTimeout(() => {
            const st = pressStates.get(id);
            if (st) st.triggered = true;
            handleWelderLongPress(welder);
        }, LONG_PRESS_MS);
        pressStates.set(id, { timeoutId, startX, startY, triggered: false });
        const target = e.target as Element | null;
        try { target?.setPointerCapture?.(id); } catch (err) { /* ignore */ }
    }

    function movePress(e: PointerEvent) {
        const id = e.pointerId;
        const st = pressStates.get(id);
        if (!st) return;
        const dx = Math.abs((e.clientX ?? 0) - st.startX);
        const dy = Math.abs((e.clientY ?? 0) - st.startY);
        if (dx > MOVE_CANCEL_PX || dy > MOVE_CANCEL_PX) {
            clearPressState(id);
        }
    }

    function endPress(e: PointerEvent) {
        const id = e.pointerId;
        const st = pressStates.get(id);
        if (!st) return;
        const hadTriggered = st.triggered;
        clearPressState(id);
        const target = e.target as Element | null;
        try { target?.releasePointerCapture?.(id); } catch (err) { /* ignore */ }
        if (hadTriggered) {
            (e.target as HTMLElement | null)?.addEventListener('click', stopImmediateOnce, { capture: true, once: true });
        }
    }

    function cancelPress(e: PointerEvent) {
        clearPressState(e.pointerId);
    }

    function clearPressState(pointerId: number) {
        const st = pressStates.get(pointerId);
        if (!st) return;
        if (st.timeoutId != null) clearTimeout(st.timeoutId);
        pressStates.delete(pointerId);
    }

    function stopImmediateOnce(ev: Event) {
        ev.stopImmediatePropagation();
        ev.preventDefault();
    }
    // --- КОНЕЦ НОВОГО ---

    // --- 4. НОВОЕ: Функции для управления модальным окном ---
    function handleWelderLongPress(welder: Welder) {
        selectedWelder = welder;
        showWelderModal = true;
    }

    function closeWelderModal() {
        showWelderModal = false;
        selectedWelder = null;
    }
    // --- КОНЕЦ НОВОГО ---

    onMount(() => {
        loadWelders();
    });
</script>

<!-- Весь экран теперь flex-контейнер -->
<div class=\"app-container\">
    <!-- Фиксированный верхний блок -->
    <header class=\"main-header\">
        <h1>Учёт сварщиков</h1>
        <div class=\"controls\">
            <div class=\"add-welder\">
                <input
                    type=\"text\"
                    placeholder=\"Фамилия сварщика\"
                    bind:value={newWelderName}
                    on:keydown={(e) => e.key === 'Enter' && addWelder()}
                />
                <button on:click={addWelder}>Добавить</button>
            </div>
            <ImportExport />
        </div>
    </header>

    <!-- Основной контент, который занимает всё оставшееся пространство -->
    <main class=\"main-content\">
        <div class=\"welder-list\">
            {#each welders as welder (welder.id)}
                <!-- 5. НОВОЕ: Добавляем обработчики долгого нажатия на каждый элемент списка -->
                <a
                    href=\"{base}/welder/{welder.id}\"
                    class=\"welder-item\"
                    role=\"button\"
                    tabindex=\"0\"
                    on:pointerdown={(e) => startPress(e as PointerEvent, welder)}
                    on:pointermove={(e) => movePress(e as PointerEvent)}
                    on:pointerup={(e) => endPress(e as PointerEvent)}
                    on:pointercancel={(e) => cancelPress(e as PointerEvent)}
                    on:keydown={(e) => e.key === 'Enter' && handleWelderLongPress(welder)}
                >
                    {welder.name}
                </a>
            {/each}
        </div>
    </main>

    <!-- Фиксированный нижний блок -->
    <footer class=\"main-footer\">
        <div class=\"nav-links\">
            <a href=\"{base}/plan\">План</a>
            <a href=\"{base}/norms\">Нормы</a>
        </div>
    </footer>
</div>

<!-- 6. НОВОЕ: Добавляем сам компонент модального окна -->
<WelderCalendarModal bind:show={showWelderModal} welder={selectedWelder} on:close={closeWelderModal} />

<style>
    .app-container {
        display: flex;
        flex-direction: column;
        height: 100vh; /* Занимаем всю высоту экрана */
        max-width: 600px;
        margin: 0 auto;
        font-family: sans-serif;
        color: #333;
    }

    .main-header {
        flex-shrink: 0; /* Не сжимается */
        padding: 1em;
        border-bottom: 1px solid #ccc; /* Сделали границу чуть мягче */
        background-color: #f0f4f8; /* Светлый сине-серый фон для заголовка */
    }

    .main-header h1 {
        margin: 0 0 0.5em 0;
        color: #4a5568; /* Темный сине-серый для текста */
    }

    .controls {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 10px;
        flex-wrap: wrap;
    }

    .add-welder {
        display: flex;
        gap: 8px;
    }

    input {
        padding: 8px;
        border: 1px solid #a0aec0; /* Мягкий сине-серый бордер */
        border-radius: 4px;
        background-color: #fff;
    }

    button {
        padding: 8px 12px;
        border: none;
        background-color: #4299e1; /* Трендовый steel blue для кнопок */
        color: white;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.2s ease, box-shadow 0.2s ease; /* Мягкие переходы без резкости */
    }

    button:hover:not(:disabled) {
        background-color: #3182ce; /* Чуть темнее для hover */
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); /* Легкая тень для глубины */
    }

    /* --- Стили для основного контента --- */
    .main-content {
        flex-grow: 1; /* Занимает всё доступное пространство */
        overflow-y: auto; /* Включаем скролл только для этого блока */
        padding: 1em;
        background-color: #edf2f7; /* Очень светлый сине-серый фон для контента */
    }

    .welder-list {
        display: flex;
        flex-direction: column;
        gap: 10px;
    }

    .welder-item {
        display: block;
        padding: 15px;
        background-color: #e2e8f0; /* Светлый сине-серый для панелей */
        border: 1px solid #cbd5e0; /* Мягкий бордер */
        border-radius: 5px;
        text-decoration: none;
        color: #2d3748; /* Темный сине-серый текст */
        transition: background-color 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease;
        /* 7. НОВОЕ: Стили для корректной работы на мобильных устройствах */
        user-select: none;
        -webkit-tap-highlight-color: transparent;
        outline: none;
        touch-action: manipulation;
        /* --- КОНЕЦ НОВЫХ СТИЛЕЙ --- */
    }

    .welder-item:hover, .welder-item:focus {
        background-color: #cbd5e0; /* Чуть темнее для hover */
        transform: translateY(-2px);
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05); /* Легкая тень без резкости */
    }

   /* --- Стили для нижнего блока --- */
    .main-footer {
        flex-shrink: 0; /* Не сжимается */
        background-color: #4a5568; /* Темный сине-серый для футера */
        padding: 1em;
        text-align: center;
        box-sizing: border-box;
    }

    .nav-links {
        display: flex;
        justify-content: center; /* Распределяем кнопки по центру */
        gap: 15px; /* Добавляем немного пространства между кнопками */
    }

    .main-footer a {
        color: white;
        text-decoration: none;
        font-weight: bold;
        padding: 10px 20px;
        border-radius: 5px;
        background-color: #4299e1; /* Steel blue для ссылок в футере */
        transition: background-color 0.2s ease, box-shadow 0.2s ease;
        /* Убираем display: inline-block, так как flex управляет расположением */
    }

    .main-footer a:hover {
        background-color: #3182ce;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }   
</style>",
  "src/routes/welder/[id]/+page.svelte": "<script lang=\"ts\">
import { onMount } from 'svelte';
import { page } from '$app/stores';
import { db, type Welder, type Plan, type Record as DbRecord, type Norm, type DailyAllocation } from '$lib/db';
import { activatedDays as rawActivatedDays } from '$lib/stores';
import type { Writable } from 'svelte/store';
import { base } from '$app/paths';

// --- Импортируем наши компоненты ---
import RecordForm from '$lib/components/RecordForm.svelte';
import RecordList from '$lib/components/RecordList.svelte';
import RecordModal from '$lib/components/RecordModal.svelte';
// --- Конец импорта ---

// --- Явно указываем тип для хранилища ---
let activatedDays: Writable<string[]> = rawActivatedDays;
// --- КОНЕЦ ---

// --- Глобальное состояние страницы ---
let welderId: number;
let welder: Welder | undefined;
let allPlans: Plan[] = [];
let records: DbRecord[] = [];

// Состояние для формы добавления
let newArticle = '';
let newQuantity = '';

// Состояние для модального окна
let selectedRecord: DbRecord | null = null;
let selectedPlan: Plan | null = null;
let showModal = false;
// --- Конец состояния ---

// --- Вычисляемые значения (reactive statements) ---
$: activePlans = allPlans.filter(p => p.isUnlimited || (p.quantity > 0 && p.completed < p.quantity));
// --- Конец вычисляемых значений ---

// --- Simple per-welder mutex (to avoid race conditions when writing dailies) ---
const welderLocks = new Map<number, Promise<void>>();

function acquireWelderLock(id: number): Promise<() => void> {
\t// Create a new \"slot\" that will be resolved when this task is done
\tlet release!: () => void;
\tconst p = new Promise<void>((res) => (release = res));

\tconst prev = welderLocks.get(id) || Promise.resolve();
\t// Chain the new slot after previous
\twelderLocks.set(id, prev.then(() => p));

\t// Return a function that resolves the current slot
\treturn Promise.resolve(() => {
\t\trelease();
\t\t// If current slot is last, clean up map entry (best-effort)
\t\tconst cur = welderLocks.get(id);
\t\t// Note: can't easily compare Promises here for identity in all engines; leave map cleanup optional
\t});
}
// --- end mutex ---

// --- Основные функции работы с данными ---
async function loadData() {
\twelder = await db.welders.get(parseInt($page.params.id!, 10));
\tif (!welder) {
\t\tconsole.error('Сварщик не найден!');
\t\treturn;
\t}
\twelderId = welder.id!;
\tallPlans = await db.plans.toArray();
\trecords = await db.records.where('welderId').equals(welderId).reverse().sortBy('date');
}

// --- Вспомогательные функции ---
function getDateString(date: Date): string {
\tconst year = date.getFullYear();
\tconst month = String(date.getMonth() + 1).padStart(2, '0');
\tconst day = String(date.getDate()).padStart(2, '0');
\treturn `${year}-${month}-${day}`;
}

function getMonthKey(date: Date): string {
\treturn `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
}

function nextWorkingDate(date: Date): Date {
\tlet next = new Date(date);
\tnext.setDate(next.getDate() + 1);
\twhile (next.getDay() === 0 || next.getDay() === 6) {
\t\tnext.setDate(next.getDate() + 1);
\t}
\treturn next;
}

// !!! FIX: считаем ВСЕ часы сварщика на дату (независимо от артикула),
// чтобы соблюдался лимит 8 часов на ячейку.
async function getOccupiedHours(_article: string, dateStr: string): Promise<number> {
\t// используем where по индексируемым полям — быстрее и корректнее
\tconst dailies: DailyAllocation[] = await db.dailies
\t\t.where({ welderId, dateStr })
\t\t.toArray();
\treturn dailies.reduce((acc: number, d: DailyAllocation) => acc + d.hours, 0);
}

// Получить map dateStr -> hours для dailies, которые принадлежали записи (используется при редактировании)
async function getRecordDailiesMap(record: DbRecord): Promise<Record<string, number>> {
\tconst map: Record<string, number> = {};
\tconst recordDate = new Date(record.date);
\tconst recordMonthKey = getMonthKey(recordDate);

\tconst dailies: DailyAllocation[] = await db.dailies
\t\t.where('welderId')
\t\t.equals(welderId)
\t\t.filter((d: DailyAllocation) => {
\t\t\tconst dMonthKey = getMonthKey(new Date(d.dateStr));
\t\t\treturn d.article === record.article && dMonthKey === recordMonthKey;
\t\t})
\t\t.toArray();

\tfor (const d of dailies) {
\t\tmap[d.dateStr] = (map[d.dateStr] || 0) + d.hours;
\t}
\treturn map;
}

// --- РАСПРЕДЕЛЕНИЕ ЧАСОВ ---
// excludeMap: optional map dateStr -> hours (часы, которые нужно вычесть из занятости БД, например старые dailies этой же записи)
async function distributeHours(article: string, totalHours: number, excludeMap: Record<string, number> = {}): Promise<{ dateStr: string; hours: number }[]> {
\tlet hoursLeft = totalHours;
\tconst dailyDistribution: { dateStr: string; hours: number }[] = [];

\tconst priorityDates = [...$activatedDays].sort((a, b) => a.localeCompare(b));
\tconst priorityDatesSet = new Set(priorityDates);

\t// локальная карта уже выделённых в этом вызове часов (чтобы не переписать одну дату несколько раз)
\tconst allocatedSoFar: Record<string, number> = {};

\t// вспомог: получить текущую занятость с учётом excludeMap и allocatedSoFar
\tasync function getEffectiveOccupied(articleLocal: string, dateStr: string): Promise<number> {
\t\tconst dbOccupied = await getOccupiedHours(articleLocal, dateStr);
\t\tconst excluded = excludeMap[dateStr] || 0;
\t\tconst alreadyAllocated = allocatedSoFar[dateStr] || 0;
\t\t// effective = (в базе - то, что мы исключаем) + то, что мы уже запланировали в этой сессии
\t\tlet effective = dbOccupied - excluded + alreadyAllocated;
\t\tif (effective < 0) effective = 0;
\t\treturn effective;
\t}

\t// ШАГ 1: Приоритетное распределение по активированным ячейкам
\tfor (const dateStr of priorityDates) {
\t\tif (hoursLeft <= 0.01) break;
\t\tconst occupied = await getEffectiveOccupied(article, dateStr);
\t\tconst free = Math.max(0, 8 - occupied);
\t\tif (free > 0) {
\t\t\tconst toAdd = Math.min(hoursLeft, free);
\t\t\tdailyDistribution.push({ dateStr, hours: toAdd });
\t\t\tallocatedSoFar[dateStr] = (allocatedSoFar[dateStr] || 0) + toAdd;
\t\t\thoursLeft -= toAdd;
\t\t}
\t}

\t// ШАГ 2: Стандартное распределение остатка с сегодняшнего дня
\tlet currentDate = new Date();
\twhile (hoursLeft > 0.01) {
\t\tconst dayString = getDateString(currentDate);
\t\tif (priorityDatesSet.has(dayString)) {
\t\t\tcurrentDate = nextWorkingDate(currentDate);
\t\t\tcontinue;
\t\t}
\t\tconst isWeekend = currentDate.getDay() === 0 || currentDate.getDay() === 6;
\t\tif (isWeekend) {
\t\t\tcurrentDate = nextWorkingDate(currentDate);
\t\t\tcontinue;
\t\t}
\t\tconst occupied = await getEffectiveOccupied(article, dayString);
\t\tconst free = Math.max(0, 8 - occupied);
\t\tif (free > 0) {
\t\t\tconst toAdd = Math.min(hoursLeft, free);
\t\t\tdailyDistribution.push({ dateStr: dayString, hours: toAdd });
\t\t\tallocatedSoFar[dayString] = (allocatedSoFar[dayString] || 0) + toAdd;
\t\t\thoursLeft -= toAdd;
\t\t}
\t\tcurrentDate = nextWorkingDate(currentDate);
\t}

\treturn dailyDistribution;
}

// --- Удаление dailies для записи ---
async function deleteDailiesForRecord(record: DbRecord) {
\tconst art = record.article;
\tconst recordDate = new Date(record.date);
\tconst recordMonthKey = getMonthKey(recordDate);

\tawait db.dailies
\t\t.where('welderId')
\t\t.equals(welderId)
\t\t.filter((d: DailyAllocation) => {
\t\t\tconst dMonthKey = getMonthKey(new Date(d.dateStr));
\t\t\treturn d.article === art && dMonthKey === recordMonthKey;
\t\t})
\t\t.delete();
}

// Тумблирование активированных дней (toggle) — вызывай из календаря по долгому тапу
function toggleActivatedDay(dateStr: string) {
\tactivatedDays.update(arr => {
\t\tconst idx = arr.indexOf(dateStr);
\t\tif (idx === -1) {
\t\t\treturn [...arr, dateStr].sort((a, b) => a.localeCompare(b));
\t\t} else {
\t\t\tconst next = arr.slice();
\t\t\tnext.splice(idx, 1);
\t\t\treturn next;
\t\t}
\t});
}

// 1. Из RecordForm: пользователь хочет добавить запись
async function handleAdd(event: CustomEvent<{ article: string; quantity: string | number }>) {
\ttry {
\t\tconst { article, quantity } = event.detail;
\t\tconst qty = parseFloat(String(quantity).replace(',', '.'));
\t\tif (article.trim() === '' || isNaN(qty) || qty <= 0) {
\t\t\talert('Введите артикул и корректное количество!');
\t\t\treturn;
\t\t}
\t\tconst activePlan = activePlans.find(p => p.article.toLowerCase() === article.trim().toLowerCase());
\t\tif (!activePlan) {
\t\t\talert('Такого артикула нет в активном плане или он уже выполнен!');
\t\t\treturn;
\t\t}

\t\tif (!activePlan.isUnlimited && activePlan.completed + qty > activePlan.quantity) {
\t\t\talert(`Нельзя добавить! Превышен план по артикулу \"${activePlan.article}\". Осталось ${(activePlan.quantity - activePlan.completed).toFixed(2).replace(/\\.?0+$/, '')}шт.`);
\t\t\treturn;
\t\t}

\t\tconst art = article.trim().toUpperCase();
\t\tconst norm = await db.norms.where('article').equals(art).first();
\t\tif (!norm) {
\t\t\talert(`Не найдена норма времени для артикула \"${art}\"!`);
\t\t\treturn;
\t\t}

\t\tconst totalHours = qty * norm.time;

\t\t// Acquire per-welder lock to avoid concurrent writes that can break the 8h limit
\t\tconst release = await acquireWelderLock(welderId);
\t\ttry {
\t\t\t// При создании новой записи excludeMap не нужен
\t\t\tconst dailyDistribution = await distributeHours(art, totalHours);

\t\t\t// Агрегация по месяцам
\t\t\tconst aggregatedQuantities = new Map<string, number>();
\t\t\tfor (const entry of dailyDistribution) {
\t\t\t\tconst date = new Date(entry.dateStr);
\t\t\t\tconst monthKey = getMonthKey(date);
\t\t\t\tconst quantityForDay = entry.hours / norm.time;
\t\t\t\taggregatedQuantities.set(monthKey, (aggregatedQuantities.get(monthKey) || 0) + quantityForDay);
\t\t\t}

\t\t\tawait db.transaction('rw', [db.records, db.plans, db.dailies], async () => {
\t\t\t\tfor (const entry of dailyDistribution) {
\t\t\t\t\tawait db.dailies.add({
\t\t\t\t\t\twelderId: welderId,
\t\t\t\t\t\tarticle: art,
\t\t\t\t\t\tdateStr: entry.dateStr,
\t\t\t\t\t\thours: entry.hours
\t\t\t\t\t});
\t\t\t\t}

\t\t\t\tfor (const [monthKey, quantity] of aggregatedQuantities.entries()) {
\t\t\t\t\tconst [year, month] = monthKey.split('-').map(Number);
\t\t\t\t\tconst recordDate = new Date(year, month - 1, 1);

\t\t\t\t\tconst existingRecord = await db.records
\t\t\t\t\t\t.where({ welderId, article: art })
\t\t\t\t\t\t.and(r => {
\t\t\t\t\t\t\tconst rDate = new Date(r.date);
\t\t\t\t\t\t\treturn rDate.getFullYear() === year && rDate.getMonth() === month - 1;
\t\t\t\t\t\t})
\t\t\t\t\t\t.first();

\t\t\t\t\tconst historyEntry = { date: new Date().toISOString(), quantity: quantity, note: `Добавлено ${quantity.toFixed(2)} шт` };
\t\t\t\t\tif (existingRecord) {
\t\t\t\t\t\tconst newTotalQuantity = existingRecord.quantity + quantity;
\t\t\t\t\t\tconst newHistory = [...JSON.parse(existingRecord.history || '[]'), historyEntry];
\t\t\t\t\t\tawait db.records.update(existingRecord.id!, { quantity: newTotalQuantity, history: JSON.stringify(newHistory) });
\t\t\t\t\t} else {
\t\t\t\t\t\tawait db.records.add({
\t\t\t\t\t\t\twelderId: welderId,
\t\t\t\t\t\t\tarticle: art,
\t\t\t\t\t\t\tquantity: quantity,
\t\t\t\t\t\t\tdate: recordDate,
\t\t\t\t\t\t\thistory: JSON.stringify([historyEntry])
\t\t\t\t\t\t});
\t\t\t\t\t}
\t\t\t\t}

\t\t\t\tactivePlan.completed += qty;
\t\t\t\tawait db.plans.update(activePlan.id!, { completed: activePlan.completed });
\t\t\t});
\t\t} finally {
\t\t\t// release lock
\t\t\trelease();
\t\t}

\t\t// НЕ очищаем activatedDays — чтобы выбор ячеек сохранялся между вводами
\t\tnewArticle = '';
\t\tnewQuantity = '';
\t\tawait loadData();

\t} catch (error) {
\t\tconsole.error(\"Ошибка при добавлении записи:\", error);
\t\talert(`Произошла ошибка! Подробности в консоли (F12).`);
\t}
}

// 2. Из RecordList: пользователь кликнул на артикул
function handleSelectArticle(event: CustomEvent<{ article: string }>) {
\tnewArticle = event.detail.article;
\tdocument.getElementById('quantity-input')?.focus();
}

// 3. Из RecordList: пользователь долго нажал на запись
function handleOpenModal(event: CustomEvent<{ record: DbRecord }>) {
\tselectedRecord = event.detail.record;
\tselectedPlan = allPlans.find(p => p.article === selectedRecord!.article) || null;
\tshowModal = true;
}

// 4. Сохранение изменённой записи
async function handleSave(event: CustomEvent<{ newQuantity: number; quantityDifference: number }>) {
\tif (!selectedRecord || !selectedPlan) return;

\tconst record = selectedRecord;
\tconst plan = selectedPlan;
\tconst { newQuantity, quantityDifference } = event.detail;

\ttry {
\t\tconst art = record.article;
\t\tconst norm = await db.norms.where('article').equals(art).first();
\t\tif (!norm) {
\t\t\talert(`Не найдена норма времени для артикула \"${art}\"!`);
\t\t\treturn;
\t\t}

\t\tconst oldQuantity = record.quantity;
\t\tconst totalHours = newQuantity * norm.time;

\t\t// --- НОВОЕ: сначала считываем, какие dailies принадлежали этой записи (map date->hours)
\t\tconst recordOwnMap = await getRecordDailiesMap(record);

\t\t// Удаляем старые dailies (как раньше)
\t\tawait deleteDailiesForRecord(record);

\t\t// Acquire per-welder lock to avoid race conditions while redistributing and writing
\t\tconst release = await acquireWelderLock(welderId);
\t\ttry {
\t\t\t// Распределяем новые часы, передавая excludeMap = recordOwnMap,
\t\t\t// чтобы distributeHours \"знал\", какие часы были нашими и не учитывал их дважды.
\t\t\tconst dailyDistribution = await distributeHours(art, totalHours, recordOwnMap);

\t\t\tawait db.transaction('rw', [db.records, db.plans, db.dailies], async () => {
\t\t\t\t// Добавляем новые dailies
\t\t\t\tfor (const entry of dailyDistribution) {
\t\t\t\t\tawait db.dailies.add({
\t\t\t\t\t\twelderId: welderId,
\t\t\t\t\t\tarticle: art,
\t\t\t\t\t\tdateStr: entry.dateStr,
\t\t\t\t\t\thours: entry.hours
\t\t\t\t\t});
\t\t\t\t}

\t\t\t\t// Обновляем запись
\t\t\t\tconst historyEntry = {
\t\t\t\t\tdate: new Date().toISOString(),
\t\t\t\t\tquantity: quantityDifference,
\t\t\t\t\tnote: `Изменено с ${oldQuantity.toFixed(2).replace(/\\.?0+$/, '')} на ${newQuantity.toFixed(2).replace(/\\.?0+$/, '')}`
\t\t\t\t};
\t\t\t\tconst newHistory = [...JSON.parse(record.history || '[]'), historyEntry];
\t\t\t\tawait db.records.update(record.id!, {
\t\t\t\t\tquantity: newQuantity,
\t\t\t\t\tdate: record.date,
\t\t\t\t\thistory: JSON.stringify(newHistory)
\t\t\t\t});

\t\t\t\t// Обновляем план
\t\t\t\tplan.completed += quantityDifference;
\t\t\t\tawait db.plans.update(plan.id!, { completed: plan.completed });
\t\t\t});
\t\t} finally {
\t\t\trelease();
\t\t}

\t\t// НЕ очищаем activatedDays — чтобы выбор ячеек сохранялся между правками
\t\tcloseModal();
\t\tawait loadData();

\t} catch (error) {
\t\tconsole.error(\"Ошибка при сохранении:\", error);
\t\talert(`Произошла ошибка! Подробности в консоли (F12).`);
\t}
}

// 5. Удаление записи
async function handleDelete() {
\tif (!selectedRecord || !selectedPlan) return;

\tconst record = selectedRecord;
\tconst plan = selectedPlan;

\ttry {
\t\t// Удаляем связанные dailies
\t\tawait deleteDailiesForRecord(record);

\t\tawait db.transaction('rw', db.records, db.plans, async () => {
\t\t\tawait db.records.delete(record.id!);
\t\t\tplan.completed -= record.quantity;
\t\t\tif (plan.completed < 0) plan.completed = 0;
\t\t\tawait db.plans.update(plan.id!, { completed: plan.completed });
\t\t});

\t\tcloseModal();
\t\tawait loadData();
\t} catch (error) {
\t\tconsole.error(\"Ошибка при удалении:\", error);
\t\talert(`Произошла ошибка! Подробности в консоли (F12).`);
\t}
}

// 6. Из RecordModal: пользователь закрыл окно
function closeModal() {
\tshowModal = false;
\tselectedRecord = null;
\tselectedPlan = null;
}
// --- Конец обработчиков ---

onMount(() => {
\tloadData();
});
</script>


<main>
{#if welder}
<h1>Карточка сварщика: {welder.name}</h1>
{:else}
<h1>Сварщик не найден</h1>
{/if}

<!-- Используем компонент формы -->
<RecordForm
  {activePlans}
  bind:newArticle
  bind:newQuantity
  on:add={handleAdd}
/>

<!-- Используем компонент списка -->
<RecordList
  {records}
  {allPlans}
  on:selectArticle={handleSelectArticle}
  on:openModal={handleOpenModal}
/>

<!-- Используем компонент модального окна -->
<RecordModal
  bind:show={showModal}
  selectedRecord={selectedRecord}
  plan={selectedPlan}
  on:save={handleSave}
  on:delete={handleDelete}
  on:close={closeModal}
/>

<!-- Фиксированная кнопка \"домой ∆\" -->
<div class=\"bottom-nav\">
<a href=\"{base}/\">домой ∆</a>
</div>
</main>

<style>
main {
\tfont-family: sans-serif;
\ttext-align: center;
\tpadding: 1em;
\tmax-width: 600px;
\tmargin: 0 auto;
\tcolor: #333;
\tpadding-bottom: 80px;
}

h1 {
\tcolor: #444;
\tborder-bottom: 2px solid #eee;
\tpadding-bottom: 10px;
\tmargin-bottom: 20px;
}

.bottom-nav {
\tposition: fixed;
\tbottom: 0;
\tleft: 0;
\twidth: 100%;
\tbackground-color: #444;
\tpadding: 1em;
\ttext-align: center;
\tbox-sizing: border-box;
}

.bottom-nav a {
\tcolor: white;
\ttext-decoration: none;
\tfont-weight: bold;
\tpadding: 10px 20px;
\tborder-radius: 5px;
\tbackground-color: #555;
\ttransition: background-color 0.2s;
}

.bottom-nav a:hover {
\tbackground-color: #666;
}
</style>",
  "src/routes/plan/+page.svelte": "<script lang=\"ts\">
    import { onMount } from 'svelte';
    import { base } from '$app/paths';
    import { db, type Plan, type Norm } from '$lib/db'; // <-- ДОБАВИЛИ type Norm

    // --- НОВОЕ: Логика для подсказок ---
    let allNorms: Norm[] = [];
    let showSuggestions = false;
    let suggestions: Norm[] = [];
    // --- КОНЕЦ НОВОГО ---

    function formatQuantity(num: number): string {
        return num.toFixed(2).replace(/\\.?0+$/, '');
    }

    let plans: Plan[] = [];
    let newArticle = '';
    let newQuantity = '';

    let showPlanModal = false;
    let selectedPlan: Plan | null = null;
    let editArticle = '';
    let editQuantity = '';

    async function loadPlans() {
        plans = await db.plans.orderBy('id').reverse().toArray();
    }

    // --- НОВОЕ: Функция загрузки норм ---
    async function loadNorms() {
        allNorms = await db.norms.orderBy('article').toArray();
    }
    // --- КОНЕЦ НОВОЕ ---

    async function addPlan() {
        const quantity = parseInt(newQuantity, 10);
        if (newArticle.trim() === '' || isNaN(quantity) || quantity < 0) {
            alert('Введите артикул и корректное количество!');
            return;
        }

        const isUnlimited = quantity === 0;

        await db.plans.add({
            article: newArticle.trim().toUpperCase(),
            quantity: quantity,
            completed: 0,
            isUnlimited: isUnlimited
        });

        newArticle = '';
        newQuantity = '';
        await loadPlans();
    }

    // --- LONG PRESS IMPLEMENTATION (без изменений) ---
    const LONG_PRESS_MS = 2000;
    const MOVE_CANCEL_PX = 10;
    type PressState = { timeoutId: number | null; startX: number; startY: number; triggered: boolean; };
    const pressStates = new Map<number, PressState>();

    function startPress(e: PointerEvent, plan: Plan) {
        if ((e instanceof PointerEvent) && e.button && e.button !== 0) return;
        const id = e.pointerId;
        const startX = (e as PointerEvent).clientX ?? 0;
        const startY = (e as PointerEvent).clientY ?? 0;
        if (pressStates.has(id)) { clearPressState(id); }
        const timeoutId = window.setTimeout(() => {
            const st = pressStates.get(id); if (st) { st.triggered = true; } handlePlanLongPress(plan);
        }, LONG_PRESS_MS);
        pressStates.set(id, { timeoutId, startX, startY, triggered: false });
        const target = e.target as Element | null;
        try { target?.setPointerCapture?.(id); } catch (err) { /* ignore */ }
    }

    function movePress(e: PointerEvent) {
        const id = e.pointerId; const st = pressStates.get(id);
        if (!st) return;
        const dx = Math.abs((e.clientX ?? 0) - st.startX);
        const dy = Math.abs((e.clientY ?? 0) - st.startY);
        if (dx > MOVE_CANCEL_PX || dy > MOVE_CANCEL_PX) { clearPressState(id); }
    }

    function endPress(e: PointerEvent) {
        const id = e.pointerId; const st = pressStates.get(id);
        if (!st) return;
        const hadTriggered = st.triggered;
        clearPressState(id);
        const target = e.target as Element | null;
        try { target?.releasePointerCapture?.(id); } catch (err) { /* ignore */ }
        if (hadTriggered) {
            (e.target as HTMLElement | null)?.addEventListener('click', stopImmediateOnce, { capture: true, once: true });
        }
    }

    function cancelPress(e: PointerEvent) { clearPressState(e.pointerId); }
    function clearPressState(pointerId: number) {
        const st = pressStates.get(pointerId);
        if (!st) return;
        if (st.timeoutId != null) { clearTimeout(st.timeoutId); }
        pressStates.delete(pointerId);
    }
    function stopImmediateOnce(ev: Event) { ev.stopImmediatePropagation(); ev.preventDefault(); }
    // --- END LONG PRESS ---

    // Модалка и действия
    function handlePlanLongPress(plan: Plan) {
        selectedPlan = plan;
        showPlanModal = true;
    }

    function openEditPlan() {
        if (selectedPlan) {
            editArticle = selectedPlan.article;
            editQuantity = selectedPlan.quantity.toString();
        }
    }

    function openCompletePlan() {
        if (selectedPlan && !selectedPlan.isUnlimited) {
            if (confirm(`Отметить план \"${selectedPlan.article}\" как выполненный?`)) {
                savePlanChanges({ completed: selectedPlan.quantity });
            }
        } else {
            alert(\"Безлимитный план нельзя отметить как выполненным.\");
        }
    }

    async function deletePlan() {
        if (!selectedPlan) return;
        if (selectedPlan.completed > 0) {
            alert(\"Нельзя удалить план, по которому уже есть выполненные работы!\");
            return;
        }
        if (confirm(`Удалить план \"${selectedPlan.article}\"?`)) {
            await db.plans.delete(selectedPlan.id!);
            closePlanModal();
            await loadPlans();
        }
    }

    async function savePlanChanges(changes: Partial<Plan>) {
        if (!selectedPlan) return;
        try {
            await db.plans.update(selectedPlan.id!, changes);
            closePlanModal();
            await loadPlans();
        } catch (error) {
            console.error(\"Ошибка при сохранении плана:\", error);
            alert(\"Не удалось сохранить изменения.\");
        }
    }

    function closePlanModal() {
        showPlanModal = false;
        selectedPlan = null;
        editArticle = '';
        editQuantity = '';
    }

    // --- НОВОЕ: Реактивная логика для подсказок ---
    $: if (newArticle.trim() !== '') {
        suggestions = allNorms.filter(norm =>
            norm.article.toLowerCase().includes(newArticle.toLowerCase())
        );
        showSuggestions = suggestions.length > 0;
    } else {
        suggestions = [];
        showSuggestions = false;
    }

    function selectSuggestion(article: string) {
        newArticle = article;
        showSuggestions = false;
        document.getElementById('quantity-input')?.focus();
    }
    // --- КОНЕЦ НОВОГО ---

    onMount(() => {
        loadPlans();
        loadNorms(); // <-- НОВОЕ: Загружаем нормы при монтировании
    });
</script>

<main>
    <h1>План работ</h1>

    <div class=\"add-plan\">
        <!-- НОВОЕ: Оборачиваем инпут в контейнер для подсказок -->
        <div class=\"input-with-suggestions\">
            <input
                type=\"text\"
                placeholder=\"Артикул\"
                bind:value={newArticle}
                on:focus={() => showSuggestions = newArticle.trim() !== ''}
            />
            {#if showSuggestions}
                <div class=\"suggestions-list\">
                    {#each suggestions as suggestion (suggestion.id)}
                       <button class=\"suggestion-item\" on:click={() => selectSuggestion(suggestion.article)}>
                           <span class=\"suggestion-article\">{suggestion.article}</span>
                           <span class=\"suggestion-info\">{suggestion.time}ч</span>
                      </button>
                    {/each}
                </div>
            {/if}
        </div>
        <!-- КОНЕЦ НОВОГО -->

        <input
            id=\"quantity-input\"
            type=\"number\"
            placeholder=\"Кол-во\"
            bind:value={newQuantity}
            on:keydown={(e) => e.key === 'Enter' && addPlan()}
        />
        <button on:click={addPlan}>Добавить</button>
    </div>

    <div class=\"plan-list\">
        {#each plans as plan (plan.id)}
            <div
                class=\"plan-item\"
                class:completed={plan.quantity > 0 && plan.completed >= plan.quantity}
                role=\"button\"
                tabindex=\"0\"
                on:pointerdown={(e) => startPress(e as PointerEvent, plan)}
                on:pointermove={(e) => movePress(e as PointerEvent)}
                on:pointerup={(e) => endPress(e as PointerEvent)}
                on:pointercancel={(e) => cancelPress(e as PointerEvent)}
                on:keydown={(e) => e.key === 'Enter' && handlePlanLongPress(plan)}
            >
                <span class=\"article\">{plan.article}</span>
                <span class=\"quantity\">{formatQuantity(plan.quantity)}шт</span>
                <span class=\"progress\">... {formatQuantity(plan.completed)}шт</span>
            </div>
        {/each}
    </div>

    {#if showPlanModal && selectedPlan}
        <div class=\"modal-overlay\" on:click={closePlanModal}>
            <div class=\"modal-content\" on:click|stopPropagation>
                <h3>Действия с планом: {selectedPlan.article}</h3>

                <div class=\"edit-section\">
                    <h4>Редактировать:</h4>
                    <input type=\"text\" placeholder=\"Артикул\" bind:value={editArticle} />
                    <input type=\"number\" placeholder=\"Количество\" bind:value={editQuantity} />
                    <button class=\"save-button\" on:click={() => savePlanChanges({ article: editArticle.trim().toUpperCase(), quantity: parseInt(editQuantity, 10) })}>
                        Сохранить изменения
                    </button>
                </div>

                <div class=\"modal-actions\">
                    <button class=\"complete-button\" on:click={openCompletePlan} disabled={selectedPlan.isUnlimited}>
                        ✅ Отметить выполненным
                    </button>
                    <button class=\"delete-button\" on:click={deletePlan}>
                        🗑️ Удалить
                    </button>
                    <button class=\"cancel-button\" on:click={closePlanModal}>Отмена</button>
                </div>
            </div>
        </div>
    {/if}

    <div class=\"bottom-nav\">
        <a href=\"{base}/\">домой ∆</a>
    </div>
</main>

<style>
    main {
        font-family: sans-serif;
        text-align: center;
        padding: 1em;
        max-width: 600px;
        margin: 0 auto;
        color: #333;
        padding-bottom: 80px;
    }

    .add-plan {
        display: flex;
        justify-content: center;
        gap: 8px;
        margin-bottom: 2em;
        flex-wrap: wrap;
    }

    input {
        padding: 8px;
        border: 1px solid #ccc;
        border-radius: 4px;
        max-width: 150px;
    }

    button {
        padding: 8px 12px;
        border: none;
        background-color: #555;
        color: white;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.2s;
    }

    button:hover:not(:disabled) {
        background-color: #777;
    }

    button:disabled {
        background-color: #ccc;
        cursor: not-allowed;
    }

    .plan-list {
        display: flex;
        flex-direction: column;
        gap: 12px;
    }

    .plan-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 15px;
        background-color: #f4f4f4;
        border: 1px solid #ddd;
        border-radius: 5px;
        transition: border-color 0.3s, background-color 0.3s;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
        outline: none;
        touch-action: manipulation;
    }

    .plan-item:hover, .plan-item:focus {
        background-color: #e8e8e8;
    }

    .plan-item.completed {
        border-color: #4caf50;
        background-color: #e8f5e9;
    }

    .article {
        font-weight: bold;
    }

    .quantity {
        color: #555;
    }

    .progress {
        color: #777;
        font-style: italic;
    }

    .bottom-nav {
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        background-color: #444;
        padding: 1em;
        text-align: center;
        box-sizing: border-box;
    }

    .bottom-nav a {
        color: white;
        text-decoration: none;
        font-weight: bold;
        padding: 10px 20px;
        border-radius: 5px;
        background-color: #555;
        transition: background-color 0.2s;
    }

    .bottom-nav a:hover {
        background-color: #666;
    }

    /* --- НОВЫЕ СТИЛИ ДЛЯ ПОДСКАЗОК --- */
    .input-with-suggestions {
        position: relative;
    }

    .suggestions-list {
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        background-color: white;
        border: 1px solid #ccc;
        border-top: none;
        border-radius: 0 0 4px 4px;
        max-height: 150px;
        overflow-y: auto;
        z-index: 10;
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }

    .suggestion-item {
        display: flex;
        justify-content: space-between;
        padding: 8px;
        cursor: pointer;
        width: 100%;
        background: none;
        border: none;
        text-align: left;
    }

    .suggestion-item:hover {
        background-color: #f0f0f0;
    }

    .suggestion-article {
        font-weight: bold;
        color: #333;
    }

    .suggestion-info {
        color: #888;
        font-size: 0.9em;
    }
    /* --- КОНЕЦ НОВЫХ СТИЛЕЙ --- */

    /* --- Стили для модального окна (без изменений) --- */
    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
    }

    .modal-content {
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        max-width: 400px;
        width: 90%;
        text-align: left;
    }

    .modal-content h3 {
        margin-top: 0;
        text-align: center;
    }

    .edit-section {
        margin: 20px 0;
        padding: 15px;
        background-color: #f9f9f9;
        border-radius: 5px;
        border: 1px solid #eee;
    }

    .edit-section h4 {
        margin-top: 0;
        margin-bottom: 10px;
    }

    .edit-section input {
        width: 100%;
        box-sizing: border-box;
        margin-bottom: 10px;
    }

    .modal-actions {
        display: flex;
        flex-direction: column;
        gap: 10px;
        margin-top: 20px;
    }

    .complete-button {
        background-color: #5cb85c;
    }

    .complete-button:hover:not(:disabled) {
        background-color: #4cae4c;
    }

    .delete-button {
        background-color: #d9534f;
    }

    .delete-button:hover {
        background-color: #c9302c;
    }

    .cancel-button {
        background-color: #777;
    }

    .cancel-button:hover {
        background-color: #555;
    }

    .save-button {
        background-color: #337ab7;
        width: 100%;
        margin-top: 10px;
    }

    .save-button:hover {
        background-color: #286090;
    }
</style>",
  "src/routes/norms/+page.svelte": "<script lang=\"ts\">
    import { onMount } from 'svelte';
    import { base } from '$app/paths';
    import { db, type Norm } from '$lib/db';

    let norms: Norm[] = [];
    let newArticle = '';
    let newTime = '';

    let showNormModal = false;
    let selectedNorm: Norm | null = null;
    let editArticle = '';
    let editTime = '';

    async function loadNorms() {
        norms = await db.norms.orderBy('article').toArray();
    }

    async function addNorm() {
        const time = parseFloat(newTime);
        if (newArticle.trim() === '' || isNaN(time) || time <= 0) {
            alert('Введите артикул и корректное время!');
            return;
        }

        await db.norms.add({
            article: newArticle.trim().toUpperCase(),
            time: time
        });

        newArticle = '';
        newTime = '';
        await loadNorms();
    }

    // --- LONG PRESS IMPLEMENTATION (реиспользуем с экрана План) ---
    const LONG_PRESS_MS = 500;
    const MOVE_CANCEL_PX = 10;

    type PressState = {
        timeoutId: number | null;
        startX: number;
        startY: number;
        triggered: boolean;
    };
    const pressStates = new Map<number, PressState>();

    function startPress(e: PointerEvent, norm: Norm) {
        if ((e instanceof PointerEvent) && e.button && e.button !== 0) return;
        const id = e.pointerId;
        const startX = (e as PointerEvent).clientX ?? 0;
        const startY = (e as PointerEvent).clientY ?? 0;
        if (pressStates.has(id)) clearPressState(id);
        const timeoutId = window.setTimeout(() => {
            const st = pressStates.get(id);
            if (st) st.triggered = true;
            handleNormLongPress(norm);
        }, LONG_PRESS_MS);
        pressStates.set(id, { timeoutId, startX, startY, triggered: false });
        const target = e.target as Element | null;
        try { target?.setPointerCapture?.(id); } catch (err) { /* ignore */ }
    }

    function movePress(e: PointerEvent) {
        const id = e.pointerId;
        const st = pressStates.get(id);
        if (!st) return;
        const dx = Math.abs((e.clientX ?? 0) - st.startX);
        const dy = Math.abs((e.clientY ?? 0) - st.startY);
        if (dx > MOVE_CANCEL_PX || dy > MOVE_CANCEL_PX) {
            clearPressState(id);
        }
    }

    function endPress(e: PointerEvent) {
        const id = e.pointerId;
        const st = pressStates.get(id);
        if (!st) return;
        const hadTriggered = st.triggered;
        clearPressState(id);
        const target = e.target as Element | null;
        try { target?.releasePointerCapture?.(id); } catch (err) { /* ignore */ }
        if (hadTriggered) {
            (e.target as HTMLElement | null)?.addEventListener('click', stopImmediateOnce, { capture: true, once: true });
        }
    }

    function cancelPress(e: PointerEvent) {
        clearPressState(e.pointerId);
    }

    function clearPressState(pointerId: number) {
        const st = pressStates.get(pointerId);
        if (!st) return;
        if (st.timeoutId != null) clearTimeout(st.timeoutId);
        pressStates.delete(pointerId);
    }

    function stopImmediateOnce(ev: Event) {
        ev.stopImmediatePropagation();
        ev.preventDefault();
    }
    // --- END LONG PRESS ---

    // Модалка и действия
    function handleNormLongPress(norm: Norm) {
        selectedNorm = norm;
        showNormModal = true;
    }

    function openEditNorm() {
        if (selectedNorm) {
            editArticle = selectedNorm.article;
            editTime = selectedNorm.time.toString();
        }
    }

    async function deleteNorm() {
        if (!selectedNorm) return;
        if (confirm(`Удалить норму \"${selectedNorm.article}\"?`)) {
            await db.norms.delete(selectedNorm.id!);
            closeNormModal();
            await loadNorms();
        }
    }

    async function saveNormChanges(changes: Partial<Norm>) {
        if (!selectedNorm) return;
        try {
            await db.norms.update(selectedNorm.id!, changes);
            closeNormModal();
            await loadNorms();
        } catch (error) {
            console.error(\"Ошибка при сохранении нормы:\", error);
            alert(\"Не удалось сохранить изменения.\");
        }
    }

    function closeNormModal() {
        showNormModal = false;
        selectedNorm = null;
        editArticle = '';
        editTime = '';
    }

    onMount(() => {
        loadNorms();
    });
</script>

<main>
    <h1>Нормы времени</h1>

    <div class=\"add-norm\">
        <input
            type=\"text\"
            placeholder=\"Артикул\"
            bind:value={newArticle}
            on:keydown={(e) => {
                if (e.key === 'Enter') {
                    document.getElementById('time-input')?.focus();
                }
            }}
        />
        <input
            id=\"time-input\"
            type=\"number\"
            step=\"0.1\"
            placeholder=\"Время (ч)\"
            bind:value={newTime}
            on:keydown={(e) => e.key === 'Enter' && addNorm()}
        />
        <button on:click={addNorm}>Добавить</button>
    </div>

    <div class=\"norm-list\">
        {#each norms as norm (norm.id)}
            <div
                class=\"norm-item\"
                role=\"button\"
                tabindex=\"0\"
                on:pointerdown={(e) => startPress(e as PointerEvent, norm)}
                on:pointermove={(e) => movePress(e as PointerEvent)}
                on:pointerup={(e) => endPress(e as PointerEvent)}
                on:pointercancel={(e) => cancelPress(e as PointerEvent)}
                on:keydown={(e) => e.key === 'Enter' && handleNormLongPress(norm)}
            >
                <span class=\"article\">{norm.article}</span>
                <span class=\"time\">{norm.time}ч</span>
            </div>
        {/each}
    </div>

    {#if showNormModal && selectedNorm}
        <div class=\"modal-overlay\" on:click={closeNormModal}>
            <div class=\"modal-content\" on:click|stopPropagation>
                <h3>Действия с нормой: {selectedNorm.article}</h3>

                <div class=\"edit-section\">
                    <h4>Редактировать:</h4>
                    <input type=\"text\" placeholder=\"Артикул\" bind:value={editArticle} />
                    <input type=\"number\" step=\"0.1\" placeholder=\"Время (ч)\" bind:value={editTime} />
                    <button class=\"save-button\" on:click={() => saveNormChanges({ article: editArticle.trim().toUpperCase(), time: parseFloat(editTime) })}>
                        Сохранить изменения
                    </button>
                </div>

                <div class=\"modal-actions\">
                    <button class=\"delete-button\" on:click={deleteNorm}>
                        🗑️ Удалить
                    </button>
                    <button class=\"cancel-button\" on:click={closeNormModal}>Отмена</button>
                </div>
            </div>
        </div>
    {/if}

    <div class=\"bottom-nav\">
        <a href=\"{base}/\">домой ∆</a>
    </div>
</main>

<style>
    main {
        font-family: sans-serif;
        text-align: center;
        padding: 1em;
        max-width: 600px;
        margin: 0 auto;
        color: #333;
        padding-bottom: 80px; /* Место для нижней навигации */
    }

    .add-norm {
        display: flex;
        justify-content: center;
        gap: 8px;
        margin-bottom: 2em;
        flex-wrap: wrap;
    }

    input {
        padding: 8px;
        border: 1px solid #ccc;
        border-radius: 4px;
        max-width: 150px;
    }

    button {
        padding: 8px 12px;
        border: none;
        background-color: #555;
        color: white;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.2s;
    }

    button:hover:not(:disabled) {
        background-color: #777;
    }

    .norm-list {
        display: flex;
        flex-direction: column;
        gap: 12px;
    }

    .norm-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 15px;
        background-color: #f4f4f4;
        border: 1px solid #ddd;
        border-radius: 5px;
        transition: border-color 0.3s, background-color 0.3s;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
        outline: none;
        touch-action: manipulation;
    }

    .norm-item:hover, .norm-item:focus {
        background-color: #e8e8e8;
    }

    .article {
        font-weight: bold;
    }

    .time {
        color: #555;
    }

    .bottom-nav {
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        background-color: #444;
        padding: 1em;
        text-align: center;
        box-sizing: border-box;
    }

    .bottom-nav a {
        color: white;
        text-decoration: none;
        font-weight: bold;
        padding: 10px 20px;
        border-radius: 5px;
        background-color: #555;
        transition: background-color 0.2s;
    }

    .bottom-nav a:hover {
        background-color: #666;
    }

    /* --- Стили для модального окна --- */
    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
    }

    .modal-content {
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        max-width: 400px;
        width: 90%;
        text-align: left;
    }

    .modal-content h3 {
        margin-top: 0;
        text-align: center;
    }

    .edit-section {
        margin: 20px 0;
        padding: 15px;
        background-color: #f9f9f9;
        border-radius: 5px;
        border: 1px solid #eee;
    }

    .edit-section h4 {
        margin-top: 0;
        margin-bottom: 10px;
    }

    .edit-section input {
        width: 100%;
        box-sizing: border-box;
        margin-bottom: 10px;
    }

    .modal-actions {
        display: flex;
        flex-direction: column;
        gap: 10px;
        margin-top: 20px;
    }

    .delete-button {
        background-color: #d9534f;
    }

    .delete-button:hover {
        background-color: #c9302c;
    }

    .cancel-button {
        background-color: #777;
    }

    .cancel-button:hover {
        background-color: #555;
    }

    .save-button {
        background-color: #337ab7;
        width: 100%;
        margin-top: 10px;
    }

    .save-button:hover {
        background-color: #286090;
    }
</style>",
  "src/lib/db.ts": "import Dexie, { type Table } from 'dexie';

export interface Welder {
id?: number;
name: string;
}

export interface Plan {
id?: number;
article: string;
quantity: number;
completed: number;
isUnlimited: boolean;
}

export interface Record {
id?: number;
welderId: number;
article: string;
quantity: number;
date: Date;
history: string;
}

// --- НОВОЕ: Интерфейс для таблицы \"Нормы\" ---
export interface Norm {
id?: number;
article: string; // Артикул, например \"ХТ637\"
time: number; // Нормативное время в часах, например 10
}
// --- КОНЕЦ НОВОГО ---

// --- НОВОЕ: Интерфейс для суточных распределений ---
export interface DailyAllocation {
id?: number;
welderId: number;
article: string;
dateStr: string; // 'YYYY-MM-DD'
hours: number;
}
// --- КОНЕЦ НОВОГО ---

export class MyDatabase extends Dexie {
welders!: Table<Welder>;
plans!: Table<Plan>;
records!: Table<Record>;
norms!: Table<Norm>;
dailies!: Table<DailyAllocation>;

constructor() {
super('MyDatabase');
// --- ИЗМЕНЕНО: Увеличиваем версию до 3 и добавляем таблицу dailies ---
this.version(3).stores({
welders: '++id, name',
plans: '++id, article, quantity, completed, isUnlimited', 
records: '++id, welderId, article, quantity, date, history',
norms: '++id, article, time',
dailies: '++id, welderId, article, dateStr, hours'
});
// --- КОНЕЦ ИЗМЕНЕНИЙ ---

// --- ИЗМЕНЕНО: Используем событие 'ready' для пост-инициализации ---
// Этот способ более надежен и не вызывает проблем с типами в TypeScript
this.on('ready', () => {
console.log(\"База данных готова. Проверяем и заполняем нормы...\");
this.populateNorms();
});
// --- КОНЕЦ ИЗМЕНЕНИЙ ---
}

// --- НОВОЕ: Метод для начального заполнения таблицы норм ---
async populateNorms() {
// Проверяем, есть ли уже записи в таблице норм
const normCount = await this.norms.count();
if (normCount === 0) {
console.log('Таблица \"Нормы\" пуста, добавляем начальные данные...');
// ВАЖНО: Замените этот массив на ваши реальные данные.
const initialNorms = [
{ article: 'ХТ637', time: 10 },
{ article: 'ХТ55', time: 12 },
{ article: 'ХТ52', time: 8 },
{ article: 'АРТ123', time: 5.5 },
{ article: 'АРТ456', time: 15 }
];
// Используем транзакцию для атомарности
await this.transaction('rw', this.norms, async () => {
await this.norms.bulkAdd(initialNorms);
});
console.log('Таблица \"Нормы\" была успешно заполнена начальными данными.');
} else {
console.log(`Таблица \"Нормы\" уже содержит ${normCount} записей.`);
}
}
// --- КОНЕЦ НОВОГО ---
}

export const db = new MyDatabase();",
  "src/lib/components/ImportExport.svelte": "<script lang=\"ts\">
    import { db, type Welder, type Plan, type Record } from '$lib/db';

    // --- Функция экспорта данных (остаётся без изменений) ---
    async function handleExport() {
        try {
            const welders = await db.welders.toArray();
            const plans = await db.plans.toArray();
            const records = await db.records.toArray();

            const exportData = {
                version: '1.0',
                exportDate: new Date().toISOString(),
                data: { welders, plans, records }
            };

            const jsonString = JSON.stringify(exportData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const today = new Date().toISOString().split('T')[0];
            a.download = `welding_data_${today}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            alert('Данные успешно экспортированы!');
        } catch (error) {
            console.error('Ошибка при экспорте:', error);
            alert('Произошла ошибка при экспорте данных. Подробности в консоли (F12).');
        }
        console.log('>>> Начинаем диагностику таблицы records...');
            const records_via_toArray = await db.records.toArray();
            const records_via_query = await db.records.where('id').above(0).toArray(); // Простой запрос, который должен получить всё

            console.log('>>> Результат db.records.toArray():', records_via_toArray);
            console.log('>>> Результат db.records.where(...).toArray():', records_via_query);
            console.log('>>> Результаты одинаковы?', JSON.stringify(records_via_toArray) === JSON.stringify(records_via_query));
            // --- КОНЕЦ ТЕСТА ---

            const records = records_via_toArray; // Используем результат toArray для экспорта
    }

    // --- НОВОЕ: Полная логика импорта ---
    let fileInput: HTMLInputElement;

    function triggerImport() {
        fileInput.click();
    }

    async function handleFileSelect(event: Event) {
        const target = event.target as HTMLInputElement;
        const file = target.files?.[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = async (e) => {
            try {
                const jsonString = e.target?.result as string;
                const importData = JSON.parse(jsonString);

                if (!importData.data) {
                    throw new Error('Неверный формат файла: отсутствует секция data.');
                }

                // Начинаем транзакцию для атомарности
                await db.transaction('rw', db.welders, db.plans, db.records, async () => {
                    // --- 1. Импорт сварщиков ---
                    const welderNameToIdMap = new Map<string, number>();
                    const existingWelders = await db.welders.toArray();
                    existingWelders.forEach(w => welderNameToIdMap.set(w.name, w.id!));

                    let addedWelders = 0;
                    for (const welder of importData.data.welders) {
                        if (!welderNameToIdMap.has(welder.name)) {
                            const id = await db.welders.add(welder);
                            welderNameToIdMap.set(welder.name, id);
                            addedWelders++;
                        }
                    }

                    // --- 2. Импорт планов ---
                    const planArticleToIdMap = new Map<string, number>();
                    const existingPlans = await db.plans.toArray();
                    existingPlans.forEach(p => planArticleToIdMap.set(p.article, p.id!));

                    let addedPlans = 0;
                    for (const plan of importData.data.plans) {
                        if (!planArticleToIdMap.has(plan.article)) {
                            const id = await db.plans.add(plan);
                            planArticleToIdMap.set(plan.article, id);
                            addedPlans++;
                        }
                    }

                    // --- 3. Импорт записей (самая важная часть) ---
                    let addedRecords = 0;
                    for (const record of importData.data.records) {
                        const welderId = welderNameToIdMap.get(record.welderName); // В файле мы ищем по имени
                        const planId = planArticleToIdMap.get(record.article);

                        // Импортируем запись, только если найдены и сварщик, и план
                        if (welderId && planId) {
                            await db.records.add({
                                ...record, // Копируем все поля (quantity, date, history)
                                welderId,  // Заменяем ID на наш, локальный
                            });
                            addedRecords++;
                        }
                    }
                    
                                        // Обновляем прогресс в планах после импорта всех записей
                    const allPlans = await db.plans.toArray();
                    for(const plan of allPlans) {
                        // ИЗМЕНЕНИЕ: Считаем сумму более надежным способом
                        const recordsForPlan = await db.records.where('article').equals(plan.article).toArray();
                        const totalCompleted = recordsForPlan.reduce((sum, record) => sum + record.quantity, 0);
                        await db.plans.update(plan.id!, { completed: totalCompleted });
                    }

                    alert(`Импорт завершен!\\n\\nДобавлено:\\n- Сварщиков: ${addedWelders}\\n- Планов: ${addedPlans}\\n- Записей: ${addedRecords}`);
                });

            } catch (error) {
                console.error('Ошибка при импорте:', error);
                alert(`Ошибка при импорте файла: ${error instanceof Error ? error.message : String(error)}`);
            } finally {
                // Сбрасываем значение input, чтобы можно было выбрать тот же файл снова
                target.value = '';
            }
        };

        reader.onerror = () => {
            alert('Не удалось прочитать файл.');
        };

        reader.readAsText(file);
    }
</script>

<!-- Скрытый input для выбора файла -->
<input bind:this={fileInput} type=\"file\" accept=\".json\" on:change={handleFileSelect} style=\"display: none;\" />

<div class=\"import-export-controls\">
    <button class=\"export-button\" on:click={handleExport}>
    ➡️ Экспорт
    </button>
    <button class=\"import-button\" on:click={triggerImport}>
    ⬅️ Импорт
    </button>
</div>

<style>
    .import-export-controls {
        display: flex;
        gap: 10px;
    }

    .import-export-controls button {
        padding: 8px 12px;
        border: none;
        background-color: #555;
        color: white;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.2s, transform 0.1s;
        font-weight: bold;
    }

    .import-export-controls button:hover {
        background-color: #777;
        transform: translateY(-1px);
    }

    .import-export-controls button:active {
        transform: translateY(0);
    }

    .export-button {
        background-color: #5cb85c;
    }

    .export-button:hover {
        background-color: #4cae4c;
    }

    .import-button {
        background-color: #f0ad4e;
    }

    .import-button:hover {
        background-color: #ec971f;
    }
</style>",
  "src/lib/components/RecordForm.svelte": "<script lang=\"ts\">
    import { createEventDispatcher } from 'svelte';
    import type { Plan } from '$lib/db';

    // --- Props (свойства), которые передаст родительский компонент ---
    export let activePlans: Plan[] = [];
    export let newArticle: string;
    export let newQuantity: string;
    // --- Конец Props ---

    const dispatch = createEventDispatcher();

    // --- Логика для подсказок (внутренняя для компонента) ---
    let showSuggestions = false;
    let suggestions: Plan[] = [];

    function formatQuantity(num: number): string {
        return num.toFixed(2).replace(/\\.?0+$/, '');
    }

    $: if (newArticle.trim() !== '') {
        suggestions = activePlans.filter(plan =>
            plan.article.toLowerCase().includes(newArticle.toLowerCase())
        );
        showSuggestions = suggestions.length > 0;
    } else {
        suggestions = [];
        showSuggestions = false;
    }

    function selectSuggestion(article: string) {
        newArticle = article;
        showSuggestions = false;
        // Фокус на следующее поле для удобства
        document.getElementById('quantity-input')?.focus();
    }

    // Функция, которая сообщит родителю о попытке добавления
    function handleAdd() {
        dispatch('add', {
            article: newArticle,
            quantity: newQuantity
        });
    }
</script>

<div class=\"add-record\">
    <div class=\"input-with-suggestions\">
        <input
            type=\"text\"
            placeholder=\"Артикул\"
            bind:value={newArticle}
            on:focus={() => showSuggestions = newArticle.trim() !== ''}
        />
        {#if showSuggestions}
            <div class=\"suggestions-list\">
                {#each suggestions as suggestion (suggestion.id)}
                   <button class=\"suggestion-item\" on:click={() => selectSuggestion(suggestion.article)}>
                       <span class=\"suggestion-article\">{suggestion.article}</span>
                       <span class=\"suggestion-info\">{formatQuantity(suggestion.completed)}/{formatQuantity(suggestion.quantity)}шт</span>
                  </button>
                {/each}
            </div>
        {/if}
    </div>

    <input
        id=\"quantity-input\"
        type=\"number\"
        step=\"0.01\"
        placeholder=\"Кол-во\"
        bind:value={newQuantity}
        on:keydown={(e) => e.key === 'Enter' && handleAdd()}
    />
    <button on:click={handleAdd}>Добавить запись</button>
</div>

<style>
    .add-record {
        display: flex;
        justify-content: center;
        gap: 8px;
        margin-bottom: 2em;
        flex-wrap: wrap;
    }

    .input-with-suggestions {
        position: relative;
    }

    input {
        padding: 8px;
        border: 1px solid #ccc;
        border-radius: 4px;
        max-width: 150px;
    }

    .suggestions-list {
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        background-color: white;
        border: 1px solid #ccc;
        border-top: none;
        border-radius: 0 0 4px 4px;
        max-height: 150px;
        overflow-y: auto;
        z-index: 10;
    }

    .suggestion-item {
        display: flex;
        justify-content: space-between;
        padding: 8px;
        cursor: pointer;
        width: 100%;
        background: none;
        border: none;
        text-align: left;
    }

    .suggestion-item:hover {
        background-color: #f0f0f0;
    }

    .suggestion-article {
        font-weight: bold;
        color: #333;
    }

    .suggestion-info {
        color: #888;
        font-size: 0.9em;
    }

    button {
        padding: 8px 12px;
        border: none;
        background-color: #555;
        color: white;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.2s;
    }

    button:hover {
        background-color: #777;
    }
    .touch-friendly {
        -webkit-tap-highlight-color: transparent;
        touch-action: manipulation;
    }

</style>",
  "src/lib/components/RecordList.svelte": "<script lang=\"ts\">
    import { createEventDispatcher } from 'svelte';
    import type { Record, Plan } from '$lib/db';

    // --- Props ---
    export let records: Record[] = [];
    export let allPlans: Plan[] = [];
    // --- Конец Props ---

    const dispatch = createEventDispatcher();

    // --- Внутренние функции-помощники ---
    function formatQuantity(num: number): string {
        return num.toFixed(2).replace(/\\.?0+$/, '');
    }

    function groupRecordsByMonth(records: Record[] | undefined) {
        if (!records || records.length === 0) {
            return new Map();
        }
        const grouped = new Map<string, Record[]>();
        for (const record of records) {
            const date = new Date(record.date);
            const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
            if (!grouped.has(monthKey)) {
                grouped.set(monthKey, []);
            }
            grouped.get(monthKey)!.push(record);
        }
        return grouped;
    }

    $: groupedRecords = groupRecordsByMonth(records);

    function getUnitForRecord(record: Record): string {
        const plan = allPlans.find(p => p.article === record.article);
        return (plan && plan.isUnlimited) ? 'ч' : 'шт';
    }

    // --- НОВАЯ ЛОГИКА ОБРАБОТКИ КЛИКОВ И ДОЛГОГО НАЖАТИЯ ---
    let pressTimer: number;

    function handlePointerDown(event: PointerEvent, record: Record) {
        // Начинаем отсчет долгого нажатия
        pressTimer = window.setTimeout(() => {
            // Если за 500мс не было отпускания, считаем это долгим нажатием
            handleLongPress(record);
        }, 500);
    }

    function handlePointerUp(event: PointerEvent, record: Record) {
        // Отпустили палец/мышь
        clearTimeout(pressTimer); // Отменяем таймер долгого нажатия

        // Проверяем, что это было короткое нажатие (не было долгого)
        // и что событие было левой кнопкой мыши или касанием пальца
        if (event.button === 0 || event.pointerType === 'touch') {
            // Проверяем, не был ли клик по кнопке-артикулу
            const target = event.target as HTMLElement;
            if (target.closest('.article-button')) {
                handleArticleClick(record.article);
            }
        }
    }

    function handlePointerCancel() {
        // Если жест прервался (например, пользователь начал скроллить)
        clearTimeout(pressTimer);
    }
    // --- КОНЕЦ НОВОЙ ЛОГИКИ ---


    // --- Функции для общения с родителем ---
    function handleArticleClick(article: string) {
        dispatch('selectArticle', { article });
    }

    function handleLongPress(record: Record) {
        dispatch('openModal', { record });
    }
    // --- Конец функций общения ---
</script>

<div class=\"record-list\">
    <h2>Выполненные работы</h2>
    {#each Array.from(groupedRecords.entries()) as [monthKey, monthRecords] (monthKey)}
        <div class=\"month-block\">
            <h3 class=\"month-header\">{new Date(monthKey + '-01').toLocaleDateString('ru-RU', { year: 'numeric', month: 'long' })}</h3>
            {#each monthRecords as record (record.id)}
                <div
                    class=\"record-item\"
                    role=\"button\"
                    tabindex=\"0\"
                    on:pointerdown={(e) => handlePointerDown(e, record)}
                    on:pointerup={(e) => handlePointerUp(e, record)}
                    on:pointercancel={handlePointerCancel}
                    on:keydown={(e) => e.key === 'Enter' && handleLongPress(record)}
                >
                    <button class=\"article-button\">{record.article}</button>
                    <span class=\"quantity\">{formatQuantity(record.quantity)}{getUnitForRecord(record)}</span>
                    <span class=\"date\">{new Date(record.date).toLocaleDateString('ru-RU')}</span>
                </div>
            {/each}
        </div>
    {/each}
</div>

<style>
    .record-list h2 {
        text-align: left;
        border-bottom: 1px solid #ddd;
        padding-bottom: 5px;
    }

    .month-block {
        margin-top: 1.5em;
    }

    .month-header {
        text-align: left;
        font-size: 1.1em;
        color: #555;
        border-bottom: 2px solid #eee;
        padding-bottom: 5px;
        margin-bottom: 10px;
    }

    .record-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px;
        border-bottom: 1px solid #eee;
        /* --- НОВЫЕ СТИЛИ ДЛЯ МОБИЛЬНЫХ УСТРОЙСТВ --- */
        user-select: none; /* Запрещаем выделение текста */
        -webkit-tap-highlight-color: transparent; /* Убираем стандартную подсветку при тапе */
        outline: none;
        touch-action: manipulation; /* Отключаем задержку на двойной тап */
        /* --- КОНЕЦ НОВЫХ СТИЛЕЙ --- */
    }

    .record-item:hover, .record-item:focus {
        background-color: #f9f9f9;
    }

    .article-button {
        font-weight: bold;
        flex-grow: 1;
        text-align: left;
        background: none;
        border: none;
        padding: 0;
        cursor: pointer;
        transition: background-color 0.2s;
        color: #333;
    }

    .article-button:hover {
        background-color: #e0e0e0;
    }

    .quantity {
        color: #555;
        margin-right: 15px;
    }

    .date {
        color: #999;
        font-size: 0.9em;
    }
</style>",
  "src/lib/components/RecordModal.svelte": "<script lang=\"ts\">
    import { createEventDispatcher, onMount } from 'svelte';
    import type { Record, Plan } from '$lib/db';

    // --- Props ---
    export let selectedRecord: Record | null = null;
    export let plan: Plan | null = null;
    export let show: boolean = false;
    // --- Конец Props ---

    const dispatch = createEventDispatcher();
    let editQuantity = '';

    // Реактивно обновляем поле ввода, когда выбрана новая запись
    $: if (selectedRecord) {
        editQuantity = selectedRecord.quantity.toString();
    }

    // --- НОВОЕ: Логика для красивой истории \"было -> стало\" ---
    $: historyChanges = calculateHistory(selectedRecord);

    function calculateHistory(record: Record | null) {
        if (!record || !record.history) return [];

        const history = JSON.parse(record.history);
        const changes = [];
        let currentQuantity = 0;

        for (const entry of history) {
            const was = currentQuantity;
            const became = currentQuantity + entry.quantity;
            changes.push({
                date: new Date(entry.date),
                was: was,
                became: became,
                note: entry.note || ''
            });
            currentQuantity = became;
        }
        return changes.reverse(); // Новые изменения сверху
    }
    // --- КОНЕЦ ЛОГИКИ ---

    function formatQuantity(num: number): string {
        return num.toFixed(2).replace(/\\.?0+$/, '');
    }

    // --- Функции для общения с родителем ---
    function handleSave() {
        if (!selectedRecord || !plan) return;

                const newQuantity = parseFloat(String(editQuantity).replace(',', '.'));
        if (isNaN(newQuantity) || newQuantity < 0) {
            alert('Введите корректное количество!');
            return;
        }

        const quantityDifference = newQuantity - selectedRecord.quantity;
        const newTotalForArticle = plan.completed + quantityDifference;

        // Проверка на превышение плана
        if (newTotalForArticle > plan.quantity) {
            alert(`Нельзя изменить! Итоговое количество (${formatQuantity(newTotalForArticle)}шт) превысит план (${formatQuantity(plan.quantity)}шт).`);
            return;
        }

        dispatch('save', { newQuantity, quantityDifference });
    }

    function handleDelete() {
        if (!selectedRecord) return;
        if (confirm(`Удалить запись \"${selectedRecord.article}\"?`)) {
            dispatch('delete');
        }
    }

    function handleClose() {
        dispatch('close');
    }
    // --- Конец функций общения ---
</script>

{#if show && selectedRecord && plan}
    <div class=\"modal-overlay\" role=\"button\" tabindex=\"0\" on:click={handleClose} on:keydown={(e) => e.key === 'Enter' && handleClose()}>
        <div class=\"modal-content\" role=\"dialog\" aria-labelledby=\"modal-title\" tabindex=\"-1\" on:click|stopPropagation on:keydown={(e) => e.key === 'Escape' && handleClose()}>
            <h3 id=\"modal-title\">Запись: {selectedRecord.article}</h3>

            <!-- Блок для редактирования количества -->
            <div class=\"edit-section\">
                <label for=\"edit-quantity-input\">Изменить количество:</label>
                <input id=\"edit-quantity-input\" type=\"number\" step=\"0.01\" bind:value={editQuantity} />
            </div>

            <!-- Блок с историей -->
            <div class=\"history-section\">
                <h4>История изменений:</h4>
                <div class=\"history-list\">
                    {#each historyChanges as change (change.date.toISOString())}
                        <div class=\"history-item\">
                            <span class=\"history-date\">{change.date.toLocaleDateString('ru-RU')}</span>
                            <span class=\"history-change\">
                                {formatQuantity(change.was)}шт --► {formatQuantity(change.became)}шт
                                {#if change.note}
                                    <span class=\"history-note\">({change.note})</span>
                                {/if}
                            </span>
                        </div>
                    {/each}
                </div>
            </div>

            <!-- Кнопки действий -->
            <div class=\"modal-actions\">
                <button class=\"save-button\" on:click={handleSave}>Сохранить</button>
                <button class=\"delete-button\" on:click={handleDelete}>🗑️ Удалить</button>
                <button class=\"cancel-button\" on:click={handleClose}>Отмена</button>
            </div>
        </div>
    </div>
{/if}

<style>
    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        outline: none;
    }

    .modal-content {
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        max-width: 450px;
        width: 90%;
        text-align: left;
    }

    .modal-content h3 {
        margin-top: 0;
        text-align: center;
        color: #333;
    }

    .edit-section {
        margin: 20px 0;
        padding: 15px;
        background-color: #f9f9f9;
        border-radius: 5px;
        border: 1px solid #eee;
    }

    .edit-section label {
        display: block;
        font-weight: bold;
        margin-bottom: 8px;
    }

    .edit-section input {
        width: 100%;
        box-sizing: border-box;
        padding: 8px;
        border: 1px solid #ccc;
        border-radius: 4px;
    }

    .history-section {
        margin-top: 20px;
    }

    .history-section h4 {
        margin-bottom: 10px;
        border-bottom: 1px solid #ddd;
        padding-bottom: 5px;
    }

    .history-list {
        max-height: 200px;
        overflow-y: auto;
        border: 1px solid #eee;
        padding: 10px;
        background-color: #fafafa;
    }

    .history-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 0;
        border-bottom: 1px solid #f0f0f0;
        font-size: 0.9em;
    }

    .history-item:last-child {
        border-bottom: none;
    }

    .history-date {
        font-weight: bold;
        color: #555;
        flex-shrink: 0;
        margin-right: 10px;
    }

    .history-change {
        color: #333;
    }

    .history-note {
        color: #888;
        font-style: italic;
    }

    .modal-actions {
        display: flex;
        flex-direction: column;
        gap: 10px;
        margin-top: 20px;
    }

    .save-button {
        background-color: #5cb85c;
    }

    .save-button:hover {
        background-color: #4cae4c;
    }

    .delete-button {
        background-color: #d9534f;
    }

    .delete-button:hover {
        background-color: #c9302c;
    }

    .cancel-button {
        background-color: #777;
    }

    .cancel-button:hover {
        background-color: #555;
    }

    button {
        padding: 10px 12px;
        border: none;
        color: white;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.2s;
        font-weight: bold;
    }
</style>"
}
